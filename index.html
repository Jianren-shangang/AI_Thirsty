<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI is Thirsty - Media Art</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }
        main {
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>
<body>
<script>
    let video;
    let startTime;
    let currentNumber;
    let prevNumber = null;
    let glitchStartTime = 0;
    let isGlitching = false;
    const GLITCH_DURATION = 200; // グリッチ効果の持続時間（ミリ秒）
    
    // 初期値を動的に計算する関数
    function calculateInitialValue() {
        const now = new Date();
        
        // 6月2日午後0時（12:00）を基準とする
        // 今年の6月2日午後0時を取得
        let referenceDate = new Date(now.getFullYear(), 5, 2, 12, 0, 0, 0); // 月は0からスタート（5 = 6月）
        
        // もし現在が6月2日午後0時より前ならば、去年の6月2日午後0時を基準とする
        if (now < referenceDate) {
            referenceDate = new Date(now.getFullYear() - 1, 5, 2, 12, 0, 0, 0);
        }
        
        // 経過時間をミリ秒で計算
        const elapsedMilliseconds = now - referenceDate;
        
        // ミリ秒を分に変換（秒は切り捨て）
        const elapsedMinutes = Math.floor(elapsedMilliseconds / 1000 / 60);
        
        // 分に4583をかけて初期値を決定
        const initialValue = elapsedMinutes * 4583;
        
        return initialValue;
    }
    
    // 作品のパラメータ
    const INCREASE_DURATION = 55; // 55秒後に数字が増加
    const COOLDOWN_DURATION = 10; // 10秒間のクールダウン
    const TOTAL_CYCLE = INCREASE_DURATION + COOLDOWN_DURATION; // 65秒の1サイクル
    const INCREMENT_PER_CYCLE = 4580; // 1サイクルで増える数
    
    // 動画のシーン情報（秒）
    const SCENE2_START = 5;  // 海の映像開始
    const SCENE2_END = 50;   // 海の映像終了
    
    function preload() {
        video = createVideo('AI_Art_video2.mp4');
    }
    
    function setup() {
        createCanvas(windowWidth, windowHeight);
        
        // 初期値を計算
        const INITIAL_VALUE = calculateInitialValue();
        currentNumber = INITIAL_VALUE;

        // 動画設定
        video.volume(0.7);
        video.hide();

        video.elt.loop = true;
        video.elt.setAttribute('playsinline', '');
        video.elt.setAttribute('webkit-playsinline', '');

        video.elt.addEventListener('ended', function () {
            video.elt.currentTime = 0;
            video.play();
        });

        // 自動再生を試みる
        video.play();

        startTime = millis();

        textAlign(CENTER, CENTER);
        textFont('Arial');
        frameRate(30);
    }
    
    function draw() {
        background(0);

        // 動画が止まっていたら再生
        if (video && video.elt.paused && video.elt.readyState >= 2) {
            video.play();
        }

        // === 動画をキャンバス中央に「全体が見えるように」フィットさせて描画 ===
        if (video && video.elt.readyState >= 2) {
            push();
            const vW = video.elt.videoWidth;
            const vH = video.elt.videoHeight;

            if (vW > 0 && vH > 0) {
                // キャンバスと動画の比率からスケールを決定（contain）
                const scale = Math.min(width / vW, height / vH);
                const drawW = vW * scale;
                const drawH = vH * scale;

                const x = (width - drawW) / 2;
                const y = (height - drawH) / 2;

                image(video, x, y, drawW, drawH);
            }
            pop();
        }

        // 経過時間を計算
        let elapsedSeconds = (millis() - startTime) / 1000;
        let cyclePosition = elapsedSeconds % TOTAL_CYCLE;

        // 55秒経過したサイクル数をカウント（55秒後に一発で増加）
        let completedIncrements = floor(elapsedSeconds / TOTAL_CYCLE);

        if (cyclePosition >= INCREASE_DURATION) {
            completedIncrements += 1;
        }

        // 初期値から始めて、サイクルごとに増加
        let newNumber = calculateInitialValue() + (completedIncrements * INCREMENT_PER_CYCLE);
        
        // 数字が変わった瞬間を検出してグリッチ効果を開始
        if (prevNumber !== null && newNumber !== prevNumber) {
            isGlitching = true;
            glitchStartTime = millis();
        }
        
        currentNumber = newNumber;
        prevNumber = newNumber;

        // 動画の現在位置を取得
        let videoTime = video.elt.currentTime;
        let isScene2 = videoTime >= SCENE2_START && videoTime <= SCENE2_END;

        push();
        textAlign(CENTER, CENTER);

        if (isScene2) {
            textSize(80);
            fill(255, 255, 255, 0);
            stroke(255, 255, 255, 80);
            strokeWeight(2.5);
        } else {
            textSize(95);
            fill(255, 255, 255, 0);
            stroke(255, 255, 255, 100);
            strokeWeight(3);
        }

        // グリッチ効果の実装
        if (isGlitching && millis() - glitchStartTime < GLITCH_DURATION) {
            let glitchProgress = (millis() - glitchStartTime) / GLITCH_DURATION;
            let glitchIntensity = (1 - glitchProgress) * 0.8; // グリッチの強さ
            
            // 複数のグリッチレイヤーを描画
            for (let i = 0; i < 5; i++) {
                // ランダムなオフセット
                let offsetX = random(-20, 20) * glitchIntensity;
                let offsetY = random(-15, 15) * glitchIntensity;
                let alpha = random(30, 150) * glitchIntensity;
                
                push();
                translate(offsetX, offsetY);
                fill(255, 255, 255, 0);
                stroke(255, random(0, 255), random(0, 255), alpha);
                strokeWeight(random(1.5, 3.5));
                text(currentNumber.toString(), width / 2, height / 2);
                pop();
            }
        } else {
            // グリッチ効果が終了したら、フラグをリセット
            isGlitching = false;
        }
        
        // 通常の数字を描画
        text(currentNumber.toString(), width / 2, height / 2);
        
        pop();
    }
    
    function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
    }
    
    // クリックで再生（自動再生がブロックされた場合の対策）
    function mousePressed() {
        if (video && !video.isPlaying()) {
            video.play();
        }
    }
</script>
</body>
</html>
